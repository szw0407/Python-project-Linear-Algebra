# Python 基础配套练习

这部分作业中有一部分的内容是需要下一次培训所讲的内容，但是为了作业的完整性，我一次性的把这些内容都放在这里了。第一次作业提交时间是本周六晚上 23:59 之前为宜。作业的目的主要是帮助大家熟悉 Python 的基本语法，以及熟悉 Python 的基本数据结构。

本周建议完成：第一步、第二步、第三步，建议考虑一下第四步，因为这往后难度就开始上升了。第五步是选做。

这次作业需要用到一部分的线性代数相关知识。如果你来自电气或者控制学院，你们已经学线性代数了，所以对于这部分数学基础应该不会有问题。如果你来自材料、能动、土木、机械等大一上学期没有开设线性代数课程的学院，你可能需要自己学习一下线性代数的相关知识。我尽量少用一些线性代数的知识，以便大家不至于为了这次作业，把一学期 2 学分的课程都补上。

以下这些内容的“第一步”、“第二步”等等，是按照难度从低到高排列的。尽量多做，但是能做多少做多少。而且，如果你认为这个题目的顺序使得你的代码很不优雅，你可以自己调整一下顺序，比如先做第二步，再做第一步。

还有就是，实现的时候只要求“兼容”，不要求“绝对一致”，比如可以函数里面参数增加一些并且有默认值，这样或许后面你自己要更灵活地使用这些方法，不要给我的要求局限了。至于兼容，就是说我用这样的方法调用这个函数必须能正常运行。

最后，要求是“能写到哪里就写到哪里”，既然是练习，如果你认为太花时间了，不写完也行，但是最好多思考和尝试一下。

## 第一步：线性代数的基本成员：向量

在 Python 中创建两个类型的对象，“行向量”(row vector)和“列向量”(column vector)。这两个对象都是一维的数组，但是行向量是一个 1×n 的数组，而列向量是一个 n×1 的数组。这两个对象都可以用来表示一个 n 维的向量。

确实，行向量和列向量都可以用 `list` 表示，但是我们需要封装一些方法在对象内，因此这个对象需要自己定义。实际上我们定义的很多方法都是 `list` 的方法，所以大家想想怎么办。（提示：继承可以继承父对象的方法——当然也可以用别的思路哦）。

对于对象内部如何存储这些数据，你可以自己决定。我现在暂且保证这部分的数据是合法的（比如没有字符串，没有空值等等）

你们需要在对象里面实现这些方法：

### 特殊方法

所谓特殊方法，就是以 `__` 开头和结尾的方法。这些方法是 Python 内置的方法，用来和 Python 的内置函数交互，比如 `print`、`len`、`str` 等等。这些方法的名字是固定的，我会列举这些方法的名字，你们需要实现这些方法。这些方法有的是需要**读取**对象的属性并用`return`返回，有的是需要**设置**或者**修改**对象的属性，有的可能需要同时干这两件事情。

- `__init__`：初始化方法，用来初始化这个对象。这个方法需要接受若干个数字，这些数字就是这个向量的元素。例如，`row_vector1 = RowVector(1, 2, 3)` 就是一个行向量，它有三个元素，分别是 1、2、3；`column_vector1 = ColumnVector(1, 2, 3)` 就是一个列向量，它有三个元素，分别是 1、2、3。

    > 提示：有一个叫做 `*args` 的东西可以帮助你实现这个功能。

- `__str__`：这个方法用来返回这个对象的字符串表示。例如，`print(row_vector1)` 就会打印出：

    ```text
    1    2    3
    ```

    而，`print(column_vector1)` 就会打印出：

    ```text
    1
    2
    3
    ```

    注意，这里的空格在字符串内部是用 `\t` 表示的。
- `__len__`：这个方法用来返回这个对象的长度。例如，`len(row_vector1)` 就会返回 3。考虑一下怎么知道这个对象的长度。
- `__getitem__`：这个方法用来返回这个对象的第 `i` 个元素。例如，`row_vector1[0]` 就会返回 1，`row_vector1[1]` 就会返回 2。考虑一下怎么知道这个对象的第 `i` 个元素。
- `__setitem__`：这个方法用来设置这个对象的第 `i` 个元素。例如，`row_vector1[0] = 2` 就会把第一个元素设置为 2。考虑一下怎么设置这个对象的第 `i` 个元素。

### 普通方法

这部分方法一般用`.` 来调用，实现更加丰富而自由的功能。

- `copy`：这个方法用来复制这个对象。例如，`row_vector2 = row_vector1.copy()` 就会把 `row_vector1` 复制一份给 `row_vector2`。
- `append`：这个方法用来在这个对象的末尾添加一个元素。例如，`row_vector1.append(4)` 就会把 4 添加到这个行（或者列，下同）向量的末尾。
- `insert`：这个方法用来在这个对象的第 `i` 个元素之前插入一个元素。例如，`row_vector1.insert(1, 4)` 就会把 4 插入到这个行向量的第 1 个元素之前。
- `pop`：这个方法用来删除这个对象的最后一个元素。例如，`row_vector1.pop()` 就会把这个行向量的最后一个元素删除。
- `remove`：这个方法用来删除这个对象的第 `i` 个元素。例如，`row_vector1.remove(1)` 就会把这个行向量的第 1 个元素删除。——这个也可以做在`pop`里面，下同（函数名称最好还是符合 Python 的思路，这个设计得确实不好）。

如果你觉得这些方法太多了，你可以只实现 `copy`、`append`、`pop` 这三个方法。

其实这部分的方法就是参考了 Python 内置的 `list` 的方法，所以是不是可以想一想，我们的对象是不是可以利用 `list` 来实现呢？

## 第二步：线性代数的基本成员：矩阵

在 Python 中创建一个“矩阵”(matrix)的对象。一个矩阵是一个 m×n 的二维数组，其中每一个元素都是一个数字。对于这个对象怎么存储数据，可能会比第一步更复杂一些了。

### 特殊方法

- `__init__`：为了简单起见，创建这个函数要求必须使用$n$个长度为$m$的行向量来表示一个$m×n$的矩阵。要求类似，`matrix1 = Matrix(row_vector1, row_vector2, row_vector3)`，其中 `row_vector1`、`row_vector2`、`row_vector3` 都是行向量。注意，这里的行向量的长度必须相同，否则这个矩阵是不合法的。
- `__str__`：这个方法用来返回这个对象的字符串表示。例如，`print(matrix1)` 就会打印出：

    ```text
    1    2    3
    4    5    6
    7    8    9
    ```

    注意，这里的空格在字符串内部是用 `\t` 表示的。
- `__getitem__`：这个方法用来返回这个对象的第 $k$ 个元素，这个元素对应了矩阵的第 $i$ 行第 $j$ 列，满足：

    ```python
    i=k//n
    j=k%n
    ```

    例如，`matrix1[0]` 就会返回 1，`matrix1[1]` 就会返回 2，`matrix1[7]` 就会返回 8。简言之就是从左到右，从上到下，从 0 开始数。

- `__setitem__`：这个方法用来设置这个对象的第 $k$ 个元素，$k$还是那么计算。
- `__len__`：这个方法用来返回$m \times n$。例如，`len(matrix1)` 就会返回 9。

### 普通方法

- `copy`：这个方法用来复制这个对象。例如，`matrix2 = matrix1.copy()` 就会把 `matrix1` 复制一份给 `matrix2`。
- `count_rows`：这个方法用来返回这个对象的行数。例如，`matrix1.count_rows()` 就会返回 3。
- `count_columns`：这个方法用来返回这个对象的列数。例如，`matrix1.count_columns()` 就会返回 3。
- `get_rows`：这个方法用来返回这个对象的行向量。例如，`matrix1.get_rows(1,3)` 就会返两个行向量，分别是第 1 行和第 3 行。
- `get_columns`：这个方法用来返回这个对象的列向量。例如，`matrix1.get_columns(1,3)` 就会返两个列向量，分别是第 1 列和第 3 列。
- `append_row`：这个方法用来在这个对象的末尾添加一行。例如，`matrix1.append_row(row_vector4)` 就会把 `row_vector4` 添加到这个矩阵的末尾。
- `insert_row`：这个方法用来在这个对象的第 `i` 行之前插入一行。例如，`matrix1.insert_row(1, row_vector4)` 就会把 `row_vector4` 插入到这个矩阵的第 1 行之前。**（选做）**
- `pop_row`：这个方法用来删除这个对象的最后一行。例如，`matrix1.pop_row()` 就会把这个矩阵的最后一行删除。
- `remove_row`：这个方法用来删除这个对象的第 `i` 行。例如，`matrix1.remove_row(1)` 就会把这个矩阵的第 1 行删除。**（选做）**
- `append_column`：这个方法用来在这个对象的末尾添加一列。例如，`matrix1.append_column(column_vector4)` 就会把 `column_vector4` 添加到这个矩阵的末尾。注意，这个方法只能用于列向量，因为行向量的末尾是没有意义的。
- `insert_column`：这个方法用来在这个对象的第 `j` 列之前插入一列。例如，`matrix1.insert_column(1, column_vector4)` 就会把 `column_vector4` 插入到这个矩阵的第 1 列之前。
- `pop_column`：这个方法用来删除这个对象的最后一列。例如，`matrix1.pop_column()` 就会把这个矩阵的最后一列删除。
- `remove_column`：这个方法用来删除这个对象的第 `j` 列。例如，`matrix1.remove_column(1)` 就会把这个矩阵的第 1 列删除。

同样的，如果你觉得这些方法太多了，你可以只实现 `copy`、`append_row`、`pop_row`、`append_column`、`pop_column` 这五个方法；如果你还是觉得有点难度，你可以只实现 `copy`、`append_row`、`pop_row` 这三个方法。

随后，我们给一个矩阵添加方法，这个方法叫做 `transpose`，这个方法用来返回这个矩阵的转置矩阵。例如，`matrix1.transpose()` 就会返回 `matrix1` 的转置矩阵。另外，如果调用 `row_vector1.transpose(operate_on_self = True)`，就会把这个矩阵自己转置了再返回，而不是返回一个新的矩阵；如果调用 `row_vector1.transpose(operate_on_self = True, copy = True)`，就会把这个矩阵自己转置了再返回，而且返回的是一个新的矩阵——相当于最后调用了一次 `copy` 方法。

## 第三步：矩阵和向量的加法和减法

矩阵和向量的加法和减法。

为了减小难度，我们不要求重载 `+` 和 `-` 运算符（当然如果你想重载也是可以的，不就是定义对应的方法嘛）。

在文件内定义两个函数，分别是 `add` 和 `subtract`。这两个函数都接受两个参数，分别是两个矩阵或者两个向量。这两个函数都返回一个矩阵或者向量，这个矩阵或者向量是两个参数的和或者差。

我们现在暂且不考虑其他情况，认为这个时候的矩阵和向量都是可以相加相减的。

另外，定义一个函数实现数乘，这个函数接受两个参数，第一个参数是一个数字，第二个参数是一个矩阵或者向量。这个函数返回一个矩阵或者向量，这个矩阵或者向量是第二个参数的每一个元素乘以第一个参数的结果。这个函数的名字可以叫做 `scaler_multiply`。

提示：

1. 如果你有一个数组 `a = [1, 2, 3]`，但是函数需要的是 `1, 2, 3`，你可以用 `*a` 来实现。
2. 如果你需要把一个数组 `a = [1, 2, 3]` 的每一个元素都乘以 2，你可以用 `[i*2 for i in a]` 来实现，这个方法叫做列表推导式。
3. 如何判断传入的参数是矩阵还是向量，这决定了我们的返回对象类型。你可以用 `isinstance` 来判断，或者简单粗暴地用 `type` 。这部分的写法很多，就看你们的想法了。

## 第四步：矩阵和向量的乘法

矩阵和向量的乘法。

其实向量也是矩阵，我们可以在这里用某种方式将向量转换为矩阵，这样就只需要写一次了。反正返回的类型都是矩阵。

这个时候我们建议重载 `*` 运算符，这样可以更加方便地使用。不过似乎难度会有点大，可以挑战一下。

为了减小难度，我们考虑一下，乘法分为三种情况，分别是：

1. 矩阵左乘矩阵
2. 矩阵右乘矩阵
3. 数乘

其中，数乘已经在上一步实现了，所以我们只需要实现前两种情况。我们可以定义一个合理的函数叫做 `multiply`。然后，我们可以在这个函数内部，根据传入的参数的类型，来判断是哪一种情况，然后调用这个函数实现对应的功能。

此时我们保证了乘法是可以进行的。

我们接下来可以给矩阵对象添加“左乘”和“右乘”的方法，这样就可以用 `matrix1.left_multiply(matrix2)` 来实现矩阵乘法了。

## 第五步（选做）

我们可以定义一个函数，这个函数叫做 `determinant`，这个函数接受一个参数，这个参数是一个矩阵。这个函数返回这个矩阵的行列式。

我们可以定义一个函数，这个函数叫做 `inverse`，这个函数接受一个参数，这个参数是一个矩阵。这个函数返回这个矩阵的逆矩阵。

我们可以定义一个函数，这个函数叫做 `rank`，这个函数接受一个参数，这个参数是一个矩阵。这个函数返回这个矩阵的秩。

还有特征值、特征向量、对角化、正交化，或者奇异值分解、QR 分解、LU 分解、Cholesky 分解、Schur 分解、Hessenberg 分解、广义逆矩阵、广义特征值、广义特征向量、广义对角化、广义正交化、广义奇异值分解、广义QR 分解、广义LU 分解、广义Cholesky 分解、广义Schur 分解、广义Hessenberg 分解、广义广义逆矩阵……这些都是线性代数的知识，如果你们有兴趣，可以自己去学习一下，然后实现一下。

## 第六步：异常处理

好了，现在我们不一定保证以上所有的函数传入值的合法性！我们需要在里面抛出合适的异常，来告诉用户他们的输入是不合法的。

什么？你觉得函数太多了，改不完？是不是有一个东西叫做“装饰器”？我们可以写一个装饰器，再用这个装饰器装饰对应的函数，这样就可以在所有的函数里面加上异常处理了。

## 第七步（挑战一下）：线性方程组

好了，现在我们的矩阵和向量的基本功能已经实现了。我们可以开始实现一些高级功能了。

读取数据的部分大家需要试着读懂已有的代码，并且把读取的文件（字符）转化为下面我们需要用到的东西。字符串里面有数字怎么办呢？考虑一下用`int`或者`float`函数，或者用`eval`函数。当然了为了安全性起见，除非能保证你的数据是安全的，否则不要用`eval`函数。（我们的文件是安全的）

输入类似这种：

```text
x+10y-12z=0
12x+18z=121
-x+18.3y-21.4z=-99.5
```

现在我们要求这样的一个字典，键为一个字符串，作为变量名；值为一个数字，作为变量的系数。例如，`{'x': 1, 'y': 2, 'z': 3}` 就表示了 $x+2y+3z$ 这个式子。

然后，我们再用一个列表来存储这些字典，并用另一个长度相等的列表来存储这些字典对应的等式的结果。例如，`[{'x': 1, 'y': 2, 'z': 3}, {'x': 4, 'y': 5, 'z': 6}]` 和 `[1, 2]` 就表示了：

$$
\begin{cases}
x+2y+3z=1\\
4x+5y+6z=2
\end{cases}
$$

这个时候，我们可以定义一个函数，这个函数叫做 `solve`，这个函数接受两个参数，第一个参数是一个字典的列表，第二个参数是一个数字的列表。这个函数返回一个矩阵对象，就是这个方程组的解（或者具体一些，是高斯消元法化简到最后的结果）。

提示：

让这个函数能把这个方程组的转化为一个增广矩阵，然后再用高斯消元法求解。

如果不会做高斯消元法，那至少要能把这个方程组转化为一个增广矩阵。这部分**建议完成**！

模拟高斯消元法的过程作为思考题，最后返回的是高斯消元法的结果。

这个时候我们还可以再做一个事情，往矩阵对象里面加入一个方法，将这个矩阵用以下的形式打印出来：

比如，对于没处理的增广矩阵，需要打印成这样（不管高亮）：

```latex
\begin{cases}
x+2y+3z=1\\
4x+5y+6z=2
\end{cases}
```

对，这个就是$\LaTeX$的语法——实际上这个 Markdown 文档内也有不少用 $\TeX$写的公式。上面的公式渲染出来是这样的：

$$
\begin{cases}
x+2y+3z=1\\
4x+5y+6z=2
\end{cases}
$$

那么，对于一个已经处理好的增广矩阵，如此打印就能呈现出：

$$
\begin{cases}
x=1\\
y=2\\
z=3
\end{cases}
$$

注意，系数为 1 的省略系数，系数为 0 的省略整项。正数打加号，负数打减号。另外，如果你最后发现一个方程是 $0=0$，那么这个方程就是多余的；如果存在任何一个方程是 $0=1$，那么这个方程组就是无解的，这个时候直接打印出 `No solution` 就可以了。

## 背景知识

好了，题目的主要部分已经讲完了，下面我们介绍一下线性代数要用到的知识。

向量是什么？就是一个一维数组。矩阵是什么？就是一个二维数组。这个二维数组的每一行都是一个向量——行向量；每一列都是一个向量——列向量。

矩阵和向量的加减法，就是把对应的元素相加减。比如：

$$
\begin{bmatrix}
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & 9
\end{bmatrix} +
\begin{bmatrix}
11 & 12 & 13\\
14 & 15 & 16\\
17 & 18 & 19
\end{bmatrix} =
\begin{bmatrix}
12 & 14 & 16\\
18 & 20 & 22\\
24 & 26 & 28
\end{bmatrix}
$$

矩阵或者向量的数乘，就是把每一个元素都乘以一个数字。比如：

$$
2 \times
\begin{bmatrix}
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & 9
\end{bmatrix} =
\begin{bmatrix}
2 & 4 & 6\\
8 & 10 & 12\\
14 & 16 & 18
\end{bmatrix}
$$

向量的内积，就是把两个向量对应的元素相乘，然后再把这些乘积相加。比如：

$$
\begin{bmatrix}
1 & 2 & 3
\end{bmatrix} \cdot
\begin{bmatrix}
4 \\ 5 \\ 6
\end{bmatrix} =
1 \times 4 + 2 \times 5 + 3 \times 6 = 32
$$

此时，这个数字也可以看作为是一个 $1 \times 1$ 的矩阵。

矩阵的乘法，就是把左边矩阵的每一行和右边矩阵的每一列做内积，然后把这些内积组成一个新的矩阵。比如

$$
\begin{align*}
&\begin{bmatrix}
1 & 2 \\
3 & 4 \\
5 & 6
\end{bmatrix} \times
\begin{bmatrix}
7 & 8 & 9 \\
10 & 11 & 12
\end{bmatrix}  \\ &=
\begin{bmatrix}
1 \times 7 + 2 \times 10 & 1 \times 8 + 2 \times 11 & 1 \times 9 + 2 \times 12 \\
3 \times 7 + 4 \times 10 & 3 \times 8 + 4 \times 11 & 3 \times 9 + 4 \times 12 \\
5 \times 7 + 6 \times 10 & 5 \times 8 + 6 \times 11 & 5 \times 9 + 6 \times 12
\end{bmatrix}  \\ &=
\begin{bmatrix}
27 & 30 & 33 \\
61 & 68 & 75 \\
95 & 106 & 117
\end{bmatrix}
\end{align*}
$$

一个 $m \times n$ 的矩阵，只能乘以一个 $n \times p$ 的矩阵，结果是一个 $m \times p$ 的矩阵。

矩阵的转置，就是把矩阵的行和列互换。比如：

$$
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix}^T =
\begin{bmatrix}
1 & 4 \\
2 & 5 \\
3 & 6
\end{bmatrix}
$$

可以考虑一下这个是不是可以用某种乘法来实现。

选做题我写着玩的，只是说这部分内容线性代数会学到……

最后讲一下增广矩阵是什么。

一个方程组，比如：

$$
\begin{cases}
x+2y+3z=1\\
4x+5y+6z=2 \\
7x+8y+9z=3
\end{cases}
$$

可以写成矩阵的形式：

$$
\begin{bmatrix}
1 & 2 & 3 & 1\\
4 & 5 & 6 & 2\\
7 & 8 & 9 & 3
\end{bmatrix}
$$

这个矩阵就是这个方程组的增广矩阵。

可以看作是系数矩阵：

$$
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
$$

右边加上一个列向量——就是等式的右侧：

$$
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
$$

如何解呢？首先我们要尽量让系数矩阵变成一个上三角矩阵——就是说，左下角尽可能全是0。然后我们再从下往上消元。这个过程叫做高斯消元法。

比如，我们先把第二行减去第一行的 4 倍，然后再把第三行减去第一行的 7 倍，就可以把第一列变成一个上三角矩阵：

$$
\begin{bmatrix}
1 & 2 & 3 & 1\\
0 & -3 & -6 & -2\\
0 & -6 & -12 & -4
\end{bmatrix}
$$

然后我们再把第三行减去第二行的 2 倍，就可以把第二列变成一个上三角矩阵：

$$
\begin{bmatrix}
1 & 2 & 3 & 1\\
0 & -3 & -6 & -2\\
0 & 0 & 0 & 0
\end{bmatrix}
$$

这个时候我们发现，这个矩阵已经左下角都是0了，没有办法通过类似的方式再化简了。另外，最后一行你发现是 $0=0$，这个方程是多余的，我们忽略就行。然后我们从下往上消元，就可以得到：

$$
\begin{bmatrix}
1 & 0 & -1 & 1\\
0 & -3 & -6 & -2 \\
0 & 0 & 0 & 0
\end{bmatrix}
$$

这个时候我们发现，第二行的第二个元素是 $-3$，我们可以把这一行除以 $-3$，就可以得到：

$$
\begin{bmatrix}
1 & 0 & -1 & 1\\
0 & 1 & 2 & \frac{2}{3} \\
0 & 0 & 0 & 0
\end{bmatrix}
$$

然后我们就可以得到：

$$
\begin{cases}
x-z=1\\
y+2z=\frac{2}{3}
\end{cases}
$$

$z$ 是一个自由变量，可以取任意值，因此这个方程组有无穷多组解。我们需要输出的就是这个模式。

简言之，先从上往下，每行都把第一个系数给消掉，然后从下往上，把后面的系数能消掉就消掉，最后就能得到一个上三角矩阵。最后我们让最左侧的项系数都是1，输出结果。
